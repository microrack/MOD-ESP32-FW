<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Firmware Flasher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .version {
            color: #666;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .version span {
            color: #667eea;
            font-weight: 600;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 500;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.flashing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.loading {
            background: #e2e3e5;
            color: #383d41;
            border: 1px solid #d6d8db;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            min-width: 150px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }

        .flash-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0 0 0;
            font-size: 0.9em;
            color: #555;
        }

        .flash-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        .flash-options input[type="checkbox"] {
            accent-color: #667eea;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        .log-container {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            display: none;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-entry.info {
            color: #0066cc;
        }

        .log-entry.success {
            color: #28a745;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .log-entry.warning {
            color: #856404;
        }

        .device-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }

        .device-info h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .device-info p {
            margin: 5px 0;
            color: #424242;
        }

        .firmware-info {
            background: #f3e5f5;
            border: 1px solid #e1bee7;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .firmware-info h3 {
            color: #7b1fa2;
            margin-bottom: 10px;
        }

        .firmware-info p {
            margin: 5px 0;
            color: #424242;
        }

        .driver-info {
            background: #fff8e1;
            border: 1px solid #ffecb3;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .driver-info h3 {
            color: #f57f17;
            margin-bottom: 10px;
        }

        .driver-info p {
            margin: 5px 0;
            color: #424242;
            font-size: 0.95em;
        }

        .driver-info a {
            color: #1565c0;
            text-decoration: none;
            font-weight: 600;
        }

        .driver-info a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ESP32 Firmware Flasher</h1>
            <div class="version">
                Version: <span id="firmwareVersion">1.0.0</span>
            </div>
        </div>

        <div id="status" class="status loading">
            Loading flash tool...
        </div>

        <div class="driver-info">
            <h3>üõ†Ô∏è Driver Prerequisites</h3>
            <p>Install the USB-to-UART driver for your board <strong>before</strong> connecting:</p>
            <p>
                <a href="https://www.silabs.com/software-and-tools/usb-to-uart-bridge-vcp-drivers" target="_blank" rel="noopener noreferrer">
                    CP210x USB to UART Bridge (Silicon Labs)
                </a>
                ‚Äî most ESP32 DevKit boards
            </p>
            <p>
                <a href="https://www.wch-ic.com/downloads/CH341SER_EXE.html" target="_blank" rel="noopener noreferrer">
                    CH340/CH9102 Driver (WCH)
                </a>
                ‚Äî NodeMCU, Wemos, and other clones
            </p>
        </div>

        <div class="firmware-info">
            <h3>üì¶ Firmware Information</h3>
            <p><strong>File:</strong> firmware.bin</p>
            <p><strong>Size:</strong> <span id="firmwareSize">Loading...</span></p>
            <p><strong>Type:</strong> <span id="firmwareType">Detecting...</span></p>
        </div>

        <div id="deviceInfo" class="device-info">
            <h3>üîå Connected Device</h3>
            <p><strong>Chip:</strong> <span id="deviceChip">-</span></p>
            <p><strong>USB Vendor:</strong> <span id="deviceVendor">-</span></p>
        </div>

        <div class="button-group">
            <button id="connectBtn" class="button" disabled>üîå Connect Device</button>
            <button id="flashBtn" class="button" disabled>‚ö° Flash Firmware</button>
            <button id="disconnectBtn" class="button" disabled>‚ùå Disconnect</button>
        </div>

        <div class="flash-options">
            <label title="Erase all flash memory before writing. Use for clean installs.">
                <input type="checkbox" id="eraseAllCheckbox"> Erase all flash
            </label>
            <label title="Hard-reset the chip after flashing completes.">
                <input type="checkbox" id="resetAfterFlash" checked> Reset after flash
            </label>
        </div>

        <div id="progressContainer" class="progress-container">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
            <div id="progressText" class="progress-text">0%</div>
        </div>

        <div id="logContainer" class="log-container">
            <div id="logContent"></div>
        </div>
    </div>

    <script type="module">
        // --- esptool-js loading -------------------------------------------------
        // Loaded as module to use ES import. The entire app lives inside this
        // module so there is no race condition between CDN fetch and app init.
        // NOTE: pin the version and consider adding SRI integrity for production.
        import * as esptooljs from 'https://unpkg.com/esptool-js@0.5.6/bundle.js';

        const ESPLoader = esptooljs.ESPLoader;
        const Transport = esptooljs.Transport;

        // Known USB vendor IDs mapped to human-readable names
        const VENDOR_NAMES = {
            0x10C4: 'Silicon Labs CP210x',
            0x1A86: 'WCH CH340/CH9102',
            0x0403: 'FTDI',
            0x303A: 'Espressif (native USB)',
            0x2341: 'Arduino',
            0x239A: 'Adafruit',
        };

        const USB_FILTERS = Object.keys(VENDOR_NAMES).map(id => ({
            usbVendorId: Number(id)
        }));

        // ESP image magic byte
        const ESP_IMAGE_MAGIC = 0xE9;

        // --- Flasher class ------------------------------------------------------
        class ESP32Flasher {
            constructor() {
                this.port = null;
                this.transport = null;
                this.loader = null;
                this.firmwareData = null;
                this.isFlashing = false;

                this.initializeElements();
                this.setupEventListeners();
                this.setupTerminal();
                this.loadFirmwareInfo();

                // Mark tool as ready
                this.updateStatus('Device not connected', 'disconnected');
                this.connectBtn.disabled = false;
                this.addLogEntry('Flash tool ready.', 'success');
            }

            initializeElements() {
                this.statusEl        = document.getElementById('status');
                this.connectBtn      = document.getElementById('connectBtn');
                this.flashBtn        = document.getElementById('flashBtn');
                this.disconnectBtn   = document.getElementById('disconnectBtn');
                this.progressContainer = document.getElementById('progressContainer');
                this.progressFill    = document.getElementById('progressFill');
                this.progressText    = document.getElementById('progressText');
                this.logContainer    = document.getElementById('logContainer');
                this.logContent      = document.getElementById('logContent');
                this.deviceInfo      = document.getElementById('deviceInfo');
                this.deviceChip      = document.getElementById('deviceChip');
                this.deviceVendor    = document.getElementById('deviceVendor');
                this.firmwareSize    = document.getElementById('firmwareSize');
                this.firmwareType    = document.getElementById('firmwareType');
                this.eraseAllCheckbox  = document.getElementById('eraseAllCheckbox');
                this.resetAfterFlash   = document.getElementById('resetAfterFlash');
            }

            setupEventListeners() {
                this.connectBtn.addEventListener('click', () => this.connectDevice());
                this.flashBtn.addEventListener('click', () => this.flashFirmware());
                this.disconnectBtn.addEventListener('click', () => this.disconnectDevice());

                // Warn user before closing tab during flash
                window.addEventListener('beforeunload', (e) => {
                    if (this.isFlashing) {
                        e.preventDefault();
                        e.returnValue = 'Firmware flash is in progress. Leaving may brick your device.';
                        return e.returnValue;
                    }
                });
            }

            setupTerminal() {
                this.terminal = {
                    clean: () => {
                        this.logContent.innerHTML = '';
                        this.logContainer.style.display = 'block';
                    },
                    writeLine: (data) => {
                        this.addLogEntry(data, 'info');
                    },
                    write: (data) => {
                        this.addLogEntry(data, 'info');
                    }
                };
            }

            addLogEntry(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const text = typeof message === 'string' ? message : JSON.stringify(message);
                // Skip empty lines from esptool-js noise
                if (!text.trim()) return;
                entry.textContent = text;
                this.logContent.appendChild(entry);
                // Auto-scroll the scrollable container, not the inner div
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
                this.logContainer.style.display = 'block';
            }

            updateStatus(message, type) {
                this.statusEl.textContent = message;
                this.statusEl.className = `status ${type}`;
            }

            updateProgress(percent, text) {
                this.progressFill.style.width = `${percent}%`;
                this.progressText.textContent = text || `${percent}%`;
            }

            // ------- Firmware loading & validation --------------------------------

            async loadFirmwareInfo() {
                try {
                    this.firmwareData = await this.getImageData('firmware.bin');
                    const byteLen = this.firmwareData.length;
                    this.firmwareSize.textContent = this.formatBytes(byteLen);

                    // Validate ESP image magic byte
                    const magic = this.firmwareData.charCodeAt(0);
                    if (magic === ESP_IMAGE_MAGIC) {
                        this.firmwareType.textContent = 'Valid ESP image (app binary)';
                    } else {
                        this.firmwareType.textContent = '‚ö†Ô∏è Unknown format ‚Äî may not be a valid ESP image';
                        this.addLogEntry(
                            `Warning: firmware magic byte is 0x${magic.toString(16).toUpperCase()}, expected 0xE9. ` +
                            'File may be corrupt or not an ESP image.',
                            'warning'
                        );
                    }
                } catch (error) {
                    this.addLogEntry(`Error loading firmware: ${error.message}`, 'error');
                    this.firmwareSize.textContent = 'Error loading firmware';
                    this.firmwareType.textContent = 'Error';
                }
            }

            async getImageData(fileURL) {
                const response = await fetch(fileURL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                // Convert to binary string in chunks to avoid stack overflow
                let result = '';
                const chunkSize = 8192;
                for (let i = 0; i < uint8Array.length; i += chunkSize) {
                    const chunk = uint8Array.slice(i, i + chunkSize);
                    result += String.fromCharCode.apply(null, chunk);
                }
                return result;
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // ------- Connection ---------------------------------------------------

            async connectDevice() {
                if (!ESPLoader || !Transport) {
                    this.addLogEntry('Flash library has not loaded yet. Please wait and retry.', 'error');
                    return;
                }
                try {
                    this.addLogEntry('Requesting device access...', 'info');

                    this.port = await navigator.serial.requestPort({
                        filters: USB_FILTERS
                    });

                    if (!this.port) {
                        throw new Error('No port selected');
                    }

                    // Do NOT open/close the port manually ‚Äî the Transport handles it.
                    this.transport = new Transport(this.port);

                    const loaderOptions = {
                        transport: this.transport,
                        baudrate: 115200,
                        terminal: this.terminal
                    };

                    this.loader = new ESPLoader(loaderOptions);

                    // Attempt connection with a timeout (30 s)
                    const mainPromise = this.loader.main();
                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error(
                            'Connection timed out. Make sure your board is in download mode (hold BOOT, press EN/RST, release BOOT).'
                        )), 30000)
                    );
                    this.chipDesc = await Promise.race([mainPromise, timeoutPromise]);
                    this.chip = this.loader.chip.CHIP_NAME;

                    this.addLogEntry(`Connected to: ${this.chip} ‚Äî ${this.chipDesc}`, 'success');

                    // Update UI
                    this.updateStatus(`Connected: ${this.chip}`, 'connected');
                    this.connectBtn.disabled = true;
                    this.flashBtn.disabled = !this.firmwareData;
                    this.disconnectBtn.disabled = false;

                    // Show device info from Web Serial (only vendorId/productId are standard)
                    const info = this.port.getInfo();
                    const vendorName = VENDOR_NAMES[info.usbVendorId] || `0x${info.usbVendorId?.toString(16).toUpperCase() ?? '????'}`;
                    this.deviceInfo.style.display = 'block';
                    this.deviceChip.textContent = `${this.chip} ‚Äî ${this.chipDesc}`;
                    this.deviceVendor.textContent = vendorName;

                } catch (error) {
                    this.addLogEntry(`Connection failed: ${error.message}`, 'error');
                    this.updateStatus(`Connection failed`, 'disconnected');
                    // Clean up partial state
                    await this.cleanupConnection();
                }
            }

            // ------- Flashing -----------------------------------------------------

            async flashFirmware() {
                if (!this.loader || !this.firmwareData || this.isFlashing) {
                    return;
                }

                this.isFlashing = true;
                this.updateStatus('Flashing firmware...', 'flashing');
                this.progressContainer.style.display = 'block';
                this.flashBtn.disabled = true;
                this.disconnectBtn.disabled = true;

                try {
                    this.addLogEntry('Starting firmware flash...', 'info');

                    const eraseAll = this.eraseAllCheckbox.checked;
                    if (eraseAll) {
                        this.addLogEntry('Erase-all enabled ‚Äî full flash erase before write.', 'warning');
                    }

                    // Use 0x10000 for standard app images; 0x0 if the binary looks
                    // like a merged/factory image (no ESP_IMAGE_MAGIC at byte 0).
                    const magic = this.firmwareData.charCodeAt(0);
                    const flashAddress = (magic === ESP_IMAGE_MAGIC) ? 0x10000 : 0x0;
                    this.addLogEntry(`Flash address: 0x${flashAddress.toString(16).toUpperCase()}`, 'info');

                    const flashOptions = {
                        fileArray: [{
                            data: this.firmwareData,
                            address: flashAddress
                        }],
                        flashSize: 'keep',
                        eraseAll: eraseAll,
                        compress: true,
                        reportProgress: (fileIndex, written, total) => {
                            const percent = Math.round((written / total) * 100);
                            this.updateProgress(percent, `Flashing: ${this.formatBytes(written)} / ${this.formatBytes(total)}`);
                        }
                    };

                    await this.loader.writeFlash(flashOptions);

                    this.addLogEntry('Firmware flashed successfully!', 'success');
                    this.updateProgress(100, 'Flash completed');
                    this.updateStatus('Firmware flashed successfully', 'connected');

                    // Hard reset after flash if requested
                    if (this.resetAfterFlash.checked) {
                        try {
                            this.addLogEntry('Resetting device...', 'info');
                            await this.loader.hardReset();
                            this.addLogEntry('Device reset complete. Firmware is now running.', 'success');
                        } catch (resetErr) {
                            this.addLogEntry(`Reset failed (non-critical): ${resetErr.message}`, 'warning');
                        }
                    }

                } catch (error) {
                    this.addLogEntry(`Flash failed: ${error.message}`, 'error');
                    this.updateStatus('Flash failed', 'disconnected');
                } finally {
                    this.isFlashing = false;
                    this.flashBtn.disabled = false;
                    this.disconnectBtn.disabled = false;
                }
            }

            // ------- Disconnect ---------------------------------------------------

            async disconnectDevice() {
                await this.cleanupConnection();
                this.updateStatus('Device not connected', 'disconnected');
                this.connectBtn.disabled = false;
                this.flashBtn.disabled = true;
                this.disconnectBtn.disabled = true;
                this.deviceInfo.style.display = 'none';
                this.progressContainer.style.display = 'none';
            }

            async cleanupConnection() {
                // Always prefer transport.disconnect() ‚Äî it handles port cleanup.
                if (this.transport) {
                    try {
                        await this.transport.disconnect();
                        this.addLogEntry('Device disconnected.', 'info');
                    } catch (error) {
                        this.addLogEntry(`Disconnect note: ${error.message}`, 'warning');
                    }
                }
                this.transport = null;
                this.port = null;
                this.loader = null;
            }
        }

        // --- Bootstrap ----------------------------------------------------------
        if (!navigator.serial) {
            document.body.innerHTML = `
                <div class="container" style="background:white;border-radius:20px;padding:40px;max-width:600px;width:100%;">
                    <div style="text-align:center;margin-bottom:30px;">
                        <h1 style="color:#333;font-size:2.5em;font-weight:300;">ESP32 Firmware Flasher</h1>
                    </div>
                    <div style="padding:15px;border-radius:10px;background:#f8d7da;color:#721c24;border:1px solid #f5c6cb;text-align:center;font-weight:500;">
                        Web Serial API is not supported in this browser.
                        Please use <strong>Chrome 89+</strong>, <strong>Edge 89+</strong>, or <strong>Opera 75+</strong>.
                        <br><br>Safari and Firefox do not support Web Serial.
                    </div>
                </div>
            `;
        } else {
            // Wait for DOM to be ready (module scripts are deferred, so DOM is parsed)
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => new ESP32Flasher());
            } else {
                new ESP32Flasher();
            }
        }
    </script>
</body>
</html> 
