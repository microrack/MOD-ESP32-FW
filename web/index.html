<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Firmware Flasher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .version {
            color: #666;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .version span {
            color: #667eea;
            font-weight: 600;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 500;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.flashing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.loading {
            background: #e2e3e5;
            color: #383d41;
            border: 1px solid #d6d8db;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            min-width: 150px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button-group {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }

        .flash-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0 0 0;
            font-size: 0.9em;
            color: #555;
        }

        .flash-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        .flash-options input[type="checkbox"] {
            accent-color: #667eea;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        .log-container {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            display: none;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-entry.info {
            color: #0066cc;
        }

        .log-entry.success {
            color: #28a745;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .log-entry.warning {
            color: #856404;
        }

        .device-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }

        .device-info h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .device-info p {
            margin: 5px 0;
            color: #424242;
        }

        .firmware-info {
            background: #f3e5f5;
            border: 1px solid #e1bee7;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .firmware-info h3 {
            color: #7b1fa2;
            margin-bottom: 10px;
        }

        .firmware-info p {
            margin: 5px 0;
            color: #424242;
        }

        .driver-info {
            background: #fff8e1;
            border: 1px solid #ffecb3;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .driver-info h3 {
            color: #f57f17;
            margin-bottom: 10px;
        }

        .driver-info p {
            margin: 5px 0;
            color: #424242;
            font-size: 0.95em;
        }

        .driver-info a {
            color: #1565c0;
            text-decoration: none;
            font-weight: 600;
        }

        .driver-info a:hover {
            text-decoration: underline;
        }

        .serial-monitor {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }

        .serial-monitor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .serial-monitor-header h3 {
            color: #4fc3f7;
            margin: 0;
        }

        .serial-monitor-header .monitor-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .serial-monitor-header .monitor-btn {
            background: #333;
            color: #ccc;
            border: 1px solid #555;
            padding: 4px 12px;
            border-radius: 5px;
            font-size: 0.8em;
            cursor: pointer;
            transition: background 0.2s;
        }

        .serial-monitor-header .monitor-btn:hover {
            background: #444;
        }

        .serial-monitor-header .monitor-btn.active {
            background: #388e3c;
            border-color: #4caf50;
            color: white;
        }

        .serial-monitor-header select {
            background: #333;
            color: #ccc;
            border: 1px solid #555;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.8em;
        }

        .serial-output {
            background: #0d0d0d;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.85em;
            color: #00ff41;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ESP32 Firmware Flasher</h1>
            <div class="version">
                Version: <span id="firmwareVersion">1.0.0</span>
            </div>
        </div>

        <div id="status" class="status loading">
            Loading flash tool...
        </div>

        <div class="driver-info">
            <h3>üõ†Ô∏è Driver Prerequisites</h3>
            <p>Install the USB-to-UART driver for your board <strong>before</strong> connecting:</p>
            <p>
                <a href="https://www.silabs.com/software-and-tools/usb-to-uart-bridge-vcp-drivers" target="_blank" rel="noopener noreferrer">
                    CP210x USB to UART Bridge (Silicon Labs)
                </a>
                ‚Äî most ESP32 DevKit boards
            </p>
            <p>
                <a href="https://www.wch-ic.com/downloads/CH341SER_EXE.html" target="_blank" rel="noopener noreferrer">
                    CH340/CH9102 Driver (WCH)
                </a>
                ‚Äî NodeMCU, Wemos, and other clones
            </p>
        </div>

        <div class="firmware-info">
            <h3>üì¶ Firmware Information</h3>
            <p><strong>File:</strong> Combined firmware (bootloader + partitions + app)</p>
            <p><strong>Size:</strong> <span id="firmwareSize">Loading...</span></p>
            <p><strong>Flash address:</strong> 0x00000000</p>
            <p><strong>Status:</strong> <span id="firmwareType">Detecting...</span></p>
        </div>

        <div id="deviceInfo" class="device-info">
            <h3>üîå Connected Device</h3>
            <p><strong>Chip:</strong> <span id="deviceChip">-</span></p>
            <p><strong>USB Vendor:</strong> <span id="deviceVendor">-</span></p>
        </div>

        <div class="button-group">
            <button id="connectBtn" class="button" disabled>üîå Connect Device</button>
            <button id="flashBtn" class="button" disabled>‚ö° Flash Firmware</button>
            <button id="disconnectBtn" class="button" disabled>‚ùå Disconnect</button>
        </div>

        <div class="flash-options">
            <label title="Erase all flash memory before writing. Use for clean installs.">
                <input type="checkbox" id="eraseAllCheckbox"> Erase all flash
            </label>
            <label title="Hard-reset the chip after flashing completes.">
                <input type="checkbox" id="resetAfterFlash" checked> Reset after flash
            </label>
        </div>

        <div id="progressContainer" class="progress-container">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
            <div id="progressText" class="progress-text">0%</div>
        </div>

        <div id="logContainer" class="log-container">
            <div id="logContent"></div>
        </div>

        <div id="serialMonitor" class="serial-monitor">
            <div class="serial-monitor-header">
                <h3>üìü Serial Monitor</h3>
                <div class="monitor-controls">
                    <select id="baudRateSelect">
                        <option value="9600">9600</option>
                        <option value="19200">19200</option>
                        <option value="38400">38400</option>
                        <option value="57600">57600</option>
                        <option value="74880">74880</option>
                        <option value="115200" selected>115200</option>
                        <option value="230400">230400</option>
                        <option value="460800">460800</option>
                        <option value="921600">921600</option>
                    </select>
                    <button id="monitorBtn" class="monitor-btn">‚ñ∂ Start</button>
                    <button id="clearMonitorBtn" class="monitor-btn">üóë Clear</button>
                </div>
            </div>
            <div id="serialOutput" class="serial-output"></div>
        </div>
    </div>

    <script type="module">
        // --- esptool-js loading -------------------------------------------------
        // Loaded as module to use ES import. The entire app lives inside this
        // module so there is no race condition between CDN fetch and app init.
        // NOTE: pin the version and consider adding SRI integrity for production.
        import * as esptooljs from 'https://unpkg.com/esptool-js@0.5.6/bundle.js';

        const ESPLoader = esptooljs.ESPLoader;
        const Transport = esptooljs.Transport;

        // Known USB vendor IDs mapped to human-readable names
        const VENDOR_NAMES = {
            0x10C4: 'Silicon Labs CP210x',
            0x1A86: 'WCH CH340/CH9102',
            0x0403: 'FTDI',
            0x303A: 'Espressif (native USB)',
            0x2341: 'Arduino',
            0x239A: 'Adafruit',
        };

        const USB_FILTERS = Object.keys(VENDOR_NAMES).map(id => ({
            usbVendorId: Number(id)
        }));

        // ESP image magic byte
        const ESP_IMAGE_MAGIC = 0xE9;

        // --- Flasher class ------------------------------------------------------
        class ESP32Flasher {
            constructor() {
                this.port = null;
                this.transport = null;
                this.loader = null;
                this.firmwareData = null;
                this.isFlashing = false;

                this.initializeElements();
                this.setupEventListeners();
                this.setupTerminal();
                this.loadFirmwareInfo();

                // Mark tool as ready
                this.updateStatus('Device not connected', 'disconnected');
                this.connectBtn.disabled = false;
                this.addLogEntry('Flash tool ready.', 'success');
            }

            initializeElements() {
                this.statusEl        = document.getElementById('status');
                this.connectBtn      = document.getElementById('connectBtn');
                this.flashBtn        = document.getElementById('flashBtn');
                this.disconnectBtn   = document.getElementById('disconnectBtn');
                this.progressContainer = document.getElementById('progressContainer');
                this.progressFill    = document.getElementById('progressFill');
                this.progressText    = document.getElementById('progressText');
                this.logContainer    = document.getElementById('logContainer');
                this.logContent      = document.getElementById('logContent');
                this.deviceInfo      = document.getElementById('deviceInfo');
                this.deviceChip      = document.getElementById('deviceChip');
                this.deviceVendor    = document.getElementById('deviceVendor');
                this.firmwareSize    = document.getElementById('firmwareSize');
                this.firmwareType    = document.getElementById('firmwareType');
                this.eraseAllCheckbox  = document.getElementById('eraseAllCheckbox');
                this.resetAfterFlash   = document.getElementById('resetAfterFlash');
                this.serialMonitor     = document.getElementById('serialMonitor');
                this.serialOutput      = document.getElementById('serialOutput');
                this.monitorBtn        = document.getElementById('monitorBtn');
                this.clearMonitorBtn   = document.getElementById('clearMonitorBtn');
                this.baudRateSelect    = document.getElementById('baudRateSelect');
            }

            setupEventListeners() {
                this.connectBtn.addEventListener('click', () => this.connectDevice());
                this.flashBtn.addEventListener('click', () => this.flashFirmware());
                this.disconnectBtn.addEventListener('click', () => this.disconnectDevice());
                this.monitorBtn.addEventListener('click', () => this.toggleMonitor());
                this.clearMonitorBtn.addEventListener('click', () => {
                    this.serialOutput.textContent = '';
                });

                // Warn user before closing tab during flash
                window.addEventListener('beforeunload', (e) => {
                    if (this.isFlashing) {
                        e.preventDefault();
                        e.returnValue = 'Firmware flash is in progress. Leaving may brick your device.';
                        return e.returnValue;
                    }
                });
            }

            setupTerminal() {
                this.terminal = {
                    clean: () => {
                        this.logContent.innerHTML = '';
                        this.logContainer.style.display = 'block';
                    },
                    writeLine: (data) => {
                        this.addLogEntry(data, 'info');
                    },
                    write: (data) => {
                        this.addLogEntry(data, 'info');
                    }
                };
            }

            addLogEntry(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const text = typeof message === 'string' ? message : JSON.stringify(message);
                // Skip empty lines from esptool-js noise
                if (!text.trim()) return;
                entry.textContent = text;
                this.logContent.appendChild(entry);
                // Auto-scroll the scrollable container, not the inner div
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
                this.logContainer.style.display = 'block';
            }

            updateStatus(message, type) {
                this.statusEl.textContent = message;
                this.statusEl.className = `status ${type}`;
            }

            updateProgress(percent, text) {
                this.progressFill.style.width = `${percent}%`;
                this.progressText.textContent = text || `${percent}%`;
            }

            // ------- Firmware loading & validation --------------------------------

            async loadFirmwareInfo() {
                try {
                    this.firmwareData = await this.getImageData('firmware.bin');
                    const byteLen = this.firmwareData.length;
                    this.firmwareSize.textContent = this.formatBytes(byteLen);

                    // Combined firmware: bootloader sits at 0x1000 inside the binary.
                    // The ESP image magic byte (0xE9) should appear at that offset.
                    const bootloaderMagic = this.firmwareData.charCodeAt(0x1000);
                    if (bootloaderMagic === ESP_IMAGE_MAGIC) {
                        this.firmwareType.textContent = 'Valid combined firmware image ‚úì';
                        this.addLogEntry(
                            `Firmware loaded: ${this.formatBytes(byteLen)} ‚Äî ` +
                            'combined image (bootloader + partitions + app) verified.',
                            'success'
                        );
                    } else if (this.firmwareData.charCodeAt(0) === ESP_IMAGE_MAGIC) {
                        // Standalone app image ‚Äî user may have provided firmware.bin instead of combined
                        this.firmwareType.textContent = '‚ö†Ô∏è Standalone app image detected';
                        this.addLogEntry(
                            'Warning: This looks like a standalone app image (not combined). ' +
                            'Flashing at 0x0 may not work correctly. Use the combined firmware from the release.',
                            'warning'
                        );
                    } else {
                        this.firmwareType.textContent = '‚ö†Ô∏è Unknown format';
                        this.addLogEntry(
                            'Warning: Could not verify firmware image format. File may be corrupt.',
                            'warning'
                        );
                    }
                } catch (error) {
                    this.addLogEntry(`Error loading firmware: ${error.message}`, 'error');
                    this.firmwareSize.textContent = 'Error loading firmware';
                    this.firmwareType.textContent = 'Error';
                }
            }

            async getImageData(fileURL) {
                const response = await fetch(fileURL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                // Convert to binary string in chunks to avoid stack overflow
                let result = '';
                const chunkSize = 8192;
                for (let i = 0; i < uint8Array.length; i += chunkSize) {
                    const chunk = uint8Array.slice(i, i + chunkSize);
                    result += String.fromCharCode.apply(null, chunk);
                }
                return result;
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // ------- Connection ---------------------------------------------------

            async connectDevice() {
                if (!ESPLoader || !Transport) {
                    this.addLogEntry('Flash library has not loaded yet. Please wait and retry.', 'error');
                    return;
                }
                try {
                    this.addLogEntry('Requesting device access...', 'info');

                    this.port = await navigator.serial.requestPort({
                        filters: USB_FILTERS
                    });

                    if (!this.port) {
                        throw new Error('No port selected');
                    }

                    // Do NOT open/close the port manually ‚Äî the Transport handles it.
                    this.transport = new Transport(this.port);

                    const loaderOptions = {
                        transport: this.transport,
                        baudrate: 115200,
                        terminal: this.terminal
                    };

                    this.loader = new ESPLoader(loaderOptions);

                    // Attempt connection with a timeout (30 s)
                    const mainPromise = this.loader.main();
                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error(
                            'Connection timed out. Make sure your board is in download mode (hold BOOT, press EN/RST, release BOOT).'
                        )), 30000)
                    );
                    this.chipDesc = await Promise.race([mainPromise, timeoutPromise]);
                    this.chip = this.loader.chip.CHIP_NAME;

                    this.addLogEntry(`Connected to: ${this.chip} ‚Äî ${this.chipDesc}`, 'success');

                    // Update UI
                    this.updateStatus(`Connected: ${this.chip}`, 'connected');
                    this.connectBtn.disabled = true;
                    this.flashBtn.disabled = !this.firmwareData;
                    this.disconnectBtn.disabled = false;

                    // Show device info from Web Serial (only vendorId/productId are standard)
                    const info = this.port.getInfo();
                    const vendorName = VENDOR_NAMES[info.usbVendorId] || `0x${info.usbVendorId?.toString(16).toUpperCase() ?? '????'}`;
                    this.deviceInfo.style.display = 'block';
                    this.deviceChip.textContent = `${this.chip} ‚Äî ${this.chipDesc}`;
                    this.deviceVendor.textContent = vendorName;

                } catch (error) {
                    this.addLogEntry(`Connection failed: ${error.message}`, 'error');
                    this.updateStatus(`Connection failed`, 'disconnected');
                    // Clean up partial state
                    await this.cleanupConnection();
                }
            }

            // ------- Flashing -----------------------------------------------------

            async flashFirmware() {
                if (!this.loader || !this.firmwareData || this.isFlashing) {
                    return;
                }

                this.isFlashing = true;
                this.updateStatus('Flashing firmware...', 'flashing');
                this.progressContainer.style.display = 'block';
                this.flashBtn.disabled = true;
                this.disconnectBtn.disabled = true;

                try {
                    this.addLogEntry('Starting firmware flash...', 'info');

                    const eraseAll = this.eraseAllCheckbox.checked;
                    if (eraseAll) {
                        this.addLogEntry('Erase-all enabled ‚Äî full flash erase before write.', 'warning');
                    }

                    // Combined firmware (bootloader + partitions + app) always starts at 0x0
                    const flashAddress = 0x0;
                    this.addLogEntry(`Flash address: 0x${flashAddress.toString(16).toUpperCase()}`, 'info');

                    const flashOptions = {
                        fileArray: [{
                            data: this.firmwareData,
                            address: flashAddress
                        }],
                        flashSize: 'keep',
                        eraseAll: eraseAll,
                        compress: true,
                        reportProgress: (fileIndex, written, total) => {
                            const percent = Math.round((written / total) * 100);
                            this.updateProgress(percent, `Flashing: ${this.formatBytes(written)} / ${this.formatBytes(total)}`);
                        }
                    };

                    await this.loader.writeFlash(flashOptions);

                    this.addLogEntry('Firmware flashed successfully!', 'success');
                    this.updateProgress(100, 'Flash completed');
                    this.updateStatus('Firmware flashed successfully', 'connected');

                    // Hard reset after flash if requested
                    if (this.resetAfterFlash.checked) {
                        try {
                            this.addLogEntry('Resetting device...', 'info');
                            await this.loader.hardReset();
                            this.addLogEntry('Device reset complete. Firmware is now running.', 'success');
                        } catch (resetErr) {
                            this.addLogEntry(`Reset failed (non-critical): ${resetErr.message}`, 'warning');
                        }

                        // Auto-start serial monitor after flash + reset
                        this.addLogEntry('Starting serial monitor...', 'info');
                        // Tear down the esptool transport so we can reopen the port cleanly
                        try { await this.transport.disconnect(); } catch(_) {}
                        this.transport = null;
                        this.loader = null;
                        // Small delay to let the port settle after reset
                        await new Promise(r => setTimeout(r, 500));
                        await this.startMonitor();
                    }

                } catch (error) {
                    this.addLogEntry(`Flash failed: ${error.message}`, 'error');
                    this.updateStatus('Flash failed', 'disconnected');
                } finally {
                    this.isFlashing = false;
                    this.flashBtn.disabled = false;
                    this.disconnectBtn.disabled = false;
                }
            }

            // ------- Disconnect ---------------------------------------------------

            async disconnectDevice() {
                await this.cleanupConnection();
                this.updateStatus('Device not connected', 'disconnected');
                this.connectBtn.disabled = false;
                this.flashBtn.disabled = true;
                this.disconnectBtn.disabled = true;
                this.deviceInfo.style.display = 'none';
                this.progressContainer.style.display = 'none';
            }

            async cleanupConnection() {
                // Stop serial monitor if running
                await this.stopMonitor();
                // Always prefer transport.disconnect() ‚Äî it handles port cleanup.
                if (this.transport) {
                    try {
                        await this.transport.disconnect();
                        this.addLogEntry('Device disconnected.', 'info');
                    } catch (error) {
                        this.addLogEntry(`Disconnect note: ${error.message}`, 'warning');
                    }
                }
                this.transport = null;
                this.port = null;
                this.loader = null;
            }

            // ------- Serial Monitor -----------------------------------------------

            async toggleMonitor() {
                if (this.monitorReader) {
                    await this.stopMonitor();
                } else {
                    await this.startMonitor();
                }
            }

            async startMonitor() {
                if (this.monitorReader) return; // Already running

                try {
                    // If port isn't set (e.g. user disconnected), re-request
                    if (!this.port) {
                        this.port = await navigator.serial.requestPort({ filters: USB_FILTERS });
                    }

                    const baudRate = parseInt(this.baudRateSelect.value, 10);

                    // Open port if not already open
                    try {
                        await this.port.open({ baudRate });
                    } catch (e) {
                        // Port might already be open ‚Äî try closing and reopening
                        if (e.message.includes('already open') || e.name === 'InvalidStateError') {
                            try { await this.port.close(); } catch(_) {}
                            await this.port.open({ baudRate });
                        } else {
                            throw e;
                        }
                    }

                    this.serialMonitor.style.display = 'block';
                    this.monitorBtn.textContent = '‚èπ Stop';
                    this.monitorBtn.classList.add('active');
                    this.addLogEntry(`Serial monitor started at ${baudRate} baud.`, 'success');

                    const decoder = new TextDecoderStream();
                    this.monitorAbortController = new AbortController();
                    this.monitorPipeline = this.port.readable.pipeTo(
                        decoder.writable,
                        { signal: this.monitorAbortController.signal }
                    ).catch(() => {}); // Suppress abort errors

                    this.monitorReader = decoder.readable.getReader();
                    this.readSerialLoop();

                } catch (error) {
                    this.addLogEntry(`Monitor error: ${error.message}`, 'error');
                    await this.stopMonitor();
                }
            }

            async readSerialLoop() {
                try {
                    while (this.monitorReader) {
                        const { value, done } = await this.monitorReader.read();
                        if (done) break;
                        if (value) {
                            this.serialOutput.textContent += value;
                            // Auto-scroll
                            this.serialOutput.scrollTop = this.serialOutput.scrollHeight;
                            // Cap buffer size to ~50 KB to avoid memory issues
                            if (this.serialOutput.textContent.length > 50000) {
                                this.serialOutput.textContent =
                                    this.serialOutput.textContent.slice(-30000);
                            }
                        }
                    }
                } catch (error) {
                    // Reader cancelled ‚Äî expected on stop
                    if (error.name !== 'TypeError') {
                        this.addLogEntry(`Monitor read error: ${error.message}`, 'warning');
                    }
                }
            }

            async stopMonitor() {
                if (this.monitorReader) {
                    try { this.monitorReader.cancel(); } catch(_) {}
                    this.monitorReader = null;
                }
                if (this.monitorAbortController) {
                    this.monitorAbortController.abort();
                    this.monitorAbortController = null;
                }
                try { await this.monitorPipeline; } catch(_) {}
                this.monitorPipeline = null;

                // Close the port so it can be reused
                if (this.port) {
                    try { await this.port.close(); } catch(_) {}
                }

                this.monitorBtn.textContent = '‚ñ∂ Start';
                this.monitorBtn.classList.remove('active');
                this.addLogEntry('Serial monitor stopped.', 'info');
            }
        }

        // --- Bootstrap ----------------------------------------------------------
        if (!navigator.serial) {
            document.body.innerHTML = `
                <div class="container" style="background:white;border-radius:20px;padding:40px;max-width:600px;width:100%;">
                    <div style="text-align:center;margin-bottom:30px;">
                        <h1 style="color:#333;font-size:2.5em;font-weight:300;">ESP32 Firmware Flasher</h1>
                    </div>
                    <div style="padding:15px;border-radius:10px;background:#f8d7da;color:#721c24;border:1px solid #f5c6cb;text-align:center;font-weight:500;">
                        Web Serial API is not supported in this browser.
                        Please use <strong>Chrome 89+</strong>, <strong>Edge 89+</strong>, or <strong>Opera 75+</strong>.
                        <br><br>Safari and Firefox do not support Web Serial.
                    </div>
                </div>
            `;
        } else {
            // Wait for DOM to be ready (module scripts are deferred, so DOM is parsed)
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => new ESP32Flasher());
            } else {
                new ESP32Flasher();
            }
        }
    </script>
</body>
</html> 
