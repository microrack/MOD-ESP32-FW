/**
 * Signal Processor: MIDI to CV/Gate/Audio Conversion
 * 
 * Core audio and control voltage generation engine. Converts MIDI messages
 * to analog voltages and digital gates suitable for modular synthesis.
 * 
 * Key responsibilities:
 * - Convert MIDI note numbers to 1V/octave pitch CV
 * - Generate velocity-scaled gate voltages
 * - Map MIDI CC to control voltages
 * - Process pitch bend (±2 semitone range)
 * - Handle MIDI clock for sequencer sync
 * - Manage polyphonic voice allocation
 * 
 * Output routing:
 * - Channels A/B: Mozzi audio synthesis (real-time DSP)
 * - Channel C: PWM CV output (1V/octave pitch)
 * - Clock/Reset: Digital gate/trigger outputs
 * 
 * See ARCHITECTURE.md for detailed signal flow.
 */

#pragma once

#include "../board.h"
#include "../urack_types.h"
#include "../midi/midi_settings_state.h"
#include "../midi/note_history.h"

// Mozzi audio library configuration
#include <MozziConfigValues.h>
#define MOZZI_AUDIO_MODE MOZZI_OUTPUT_PWM         // PWM audio output mode
#define MOZZI_CONTROL_RATE 1024                   // Control update rate (Hz)
#define MOZZI_AUDIO_RATE PWM_FREQ                 // Audio sample rate (32768 Hz)
#define MOZZI_AUDIO_CHANNELS 2                    // Stereo output
#define MOZZI_AUDIO_PIN_1 OUT_CHANNEL_A_PIN       // Left channel pin (26)
#define MOZZI_AUDIO_PIN_2 OUT_CHANNEL_B_PIN       // Right channel pin (25)
#define MOZZI_ANALOG_READ MOZZI_ANALOG_READ_NONE  // No analog reading needed

// Forward declaration for AudioOutput (defined in AudioOutput.h)
struct StereoOutput;
typedef StereoOutput AudioOutput;

/**
 * Processor Event Types
 * 
 * Events generated by MIDI input and internal clock for custom processing.
 * Used for external audio synthesis algorithms to respond to musical events.
 */
enum ProcessorEventType {
    EventControl,              // Control rate tick (1024 Hz)
    EventClock,                // MIDI clock tick (24 per quarter note)
    EventStart,                // MIDI start (sequencer play)
    EventStop,                 // MIDI stop (sequencer stop)
    EventNoteOn,               // Note on (note, velocity)
    EventNoteOff,              // Note off (note)
    EventCc,                   // Control change (CC number, value)
    EventAftertouch,           // Channel pressure
    EventPitchBend             // Pitch bend wheel (-8192 to +8191)
};

/**
 * Processor Event Data
 * 
 * Union containing event-specific parameters.
 * Access the appropriate struct member based on ProcessorEventType.
 */
union ProcessorEvent {
    struct {
        // Empty struct for events without parameters (Control, Clock, Start, Stop)
    } empty;
    
    struct {
        uint8_t channel;       // Output channel (0 or 1 for Mozzi channels)
        uint8_t note;          // MIDI note number (0-127, Middle C = 60)
        uint8_t velocity;      // Note velocity (0-127)
        uint8_t id;            // Note ID for polyphonic tracking
    } note;
    
    struct {
        uint8_t channel;       // Output channel (0 or 1)
        uint8_t cc;            // MIDI CC number (0-127)
        uint8_t value;         // CC value (0-127)
    } cc;
    
    struct {
        uint8_t channel;       // Output channel (0 or 1)
        uint8_t value;         // Aftertouch value (0-127)
    } aftertouch;
    
    struct {
        uint8_t channel;       // Output channel (0 or 1)
        int value;             // Pitch bend value (-8192 to +8191, 0 = center)
    } pitchbend;
};

/**
 * SignalProcessor Class
 * 
 * Main audio and CV generation engine. Processes MIDI events and generates
 * corresponding voltages/gates on hardware outputs.
 * 
 * Threading model:
 * - Constructor/begin: Main thread
 * - MIDI handlers: FreeRTOS MIDI task
 * - Audio callback: Mozzi timer interrupt (high priority)
 * 
 * Output mapping:
 * - Channel routing configurable via MIDI settings
 * - Supports per-channel MIDI channel assignment
 * - Note priority modes: last, low, high
 */
class SignalProcessor {
public:
    SignalProcessor(MidiSettingsState* state);
    MidiSettingsState* state;  // Pointer to persistent MIDI configuration

    void begin(void);  // Initialize signal processor and start MIDI task
    
    // MIDI event handlers (called from MIDI library callbacks)
    void handle_note_on(uint8_t channel, uint8_t note, uint8_t velocity);
    void handle_note_off(uint8_t channel, uint8_t note, uint8_t velocity);
    void handle_cc(uint8_t channel, uint8_t cc, uint8_t value);
    void handle_aftertouch(uint8_t channel, uint8_t value);
    void handle_pitchbend(uint8_t channel, int value);  // value: -8192 to +8191
    void handle_clock(void);   // MIDI clock tick (24 per quarter note)
    void handle_start(void);   // Sequencer start
    void handle_stop(void);    // Sequencer stop
    void clock_routine(void);  // Internal clock processing

    // Output control
    void out_7bit_value(int pwm_ch, int value);  // Output 7-bit MIDI value as CV

    // State tracking
    uint8_t last_out[OutChannelCount];              // Last output values per channel
    uint8_t last_cc[MIDI_CHANNEL_COUNT];            // Last CC number per MIDI channel
    int pitchbend[MIDI_CHANNEL_COUNT];              // Pitch bend per MIDI channel
    
    bool osc_enabled[2];                            // Mozzi oscillator enable flags
    int mozzi_out[2];                               // Mozzi audio output values
    
    // Callback function types for external audio synthesis
    typedef AudioOutput (*UpdateAudioCallback)(void);       // Audio generation callback
    typedef void (*EventCallback)(ProcessorEventType, ProcessorEvent);  // Event notification
    
    // Callback registration (for custom audio synthesis algorithms)
    void set_update_audio_callback(UpdateAudioCallback callback) {
        update_audio_callback = callback;
    }
    
    void set_event_callback(EventCallback callback) {
        event_callback = callback;
    }

    UpdateAudioCallback update_audio_callback;  // Called at audio rate (32768 Hz)
    EventCallback event_callback;               // Called on MIDI/control events

    // Pitch bend range in semitones (±2 semitones is MIDI standard)
    static constexpr float PITCHBEND_RANGE_SEMITONES = 2.0f;

private:
    // CV Calibration Constants
    // These values calibrate the PWM output to produce 1V/octave pitch CV
    static constexpr float PWM_NOTE_SCALE = (1 << PWM_RESOLUTION) / (12 * 10.99);  // Scaling factor for 1V/oct
    static const int PWM_ZERO_OFFSET = 498;     // PWM value for 0V (at MIDDLE_NOTE)
    static const int MIDDLE_NOTE = 60;          // MIDI note for 0V reference (Middle C)
        
    // Polyphonic voice tracking (one history per MIDI channel)
    NoteHistory note_history[MIDI_CHANNEL_COUNT];
    TaskHandle_t midi_task_handle;              // FreeRTOS task for MIDI processing
    
    // Clock frequency measurement (for tempo sync)
    static constexpr int CLOCK_TICKS_PER_BEAT = 24;  // MIDI clock standard (24 PPQ)
    static constexpr unsigned long MAX_CLOCK_TICK_DURATION = 4;  // Max clock pulse width
    unsigned long clock_last_time;
    int clock_tick_count;
    unsigned long clock_measurement_start;
    unsigned long internal_clock_last_tick_time; // Time of last internal clock tick
    
    void out_gate(int pwm_ch, int velocity);
    void out_pitch(int pwm_ch, int note, int pitchbend_value = 0);
    
    static void midi_task(void* parameter);

    inline bool is_global_channel_match(uint8_t channel) const {
        return (state->get_midi_channel() == channel) ||
               (state->get_midi_channel() == MidiChannelAll);
    }

    inline bool is_out_channel_match(int out_channel, uint8_t channel) const {
        if(state->get_midi_out_channel(out_channel) == MidiChannelUnchanged) return is_global_channel_match(channel);

        return (state->get_midi_out_channel(out_channel) == channel) ||
               (state->get_midi_out_channel(out_channel) == MidiChannelAll);
    }
};
